![Icon](https://github.com/DaveSenn/ConfigurationPlaceholders/blob/master/data/icon_100.png?raw=true)

# ConfigurationPlaceholders 

[![Latest Release](https://img.shields.io/nuget/v/ConfigurationPlaceholders?logo=nuget&label=release&style=flat-square)](https://www.nuget.org/packages/ConfigurationPlaceholders)
[![Latest Pre-Release](https://img.shields.io/nuget/vpre/ConfigurationPlaceholders?logo=nuget&color=yellow&label=pre-release&style=flat-square)](https://www.nuget.org/packages/ConfigurationPlaceholders/absoluteLatest)
[![Downloads](https://img.shields.io/nuget/dt/ConfigurationPlaceholders.svg?style=flat-square&logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY%2Fl8WUAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAABrUlEQVR4XuXQQW7DMAxE0Rw1R%2BtN3XAjBOpPaptfsgkN8DazIDB8bNu2NCxXguVKsFwJlrJs6KYGS1k2dFODpSwbuqnBUpYN3dRgKcuGbmqwlGVDNzVYyrKhmxosZdnQTQ2WsmzopgZLWTZ0U4OlLBu6qcFSlg3d1GApy4ZuarCUZUM3NVjKsqGbGixl2dBNDZaybOimBktZNnRTg6UsG7qpwVKWDd3UYPnB86VKfl5owx9YflHhCbvHByz%2FcecnHBofsNzhjk84PD5gudOdnnBqfMDygDs84fT4gOVBVz4hNT5gecIVT0iPD1ieNPMJyviAZcKMJ2jjA5ZJI5%2Bgjg9YCkY8QR8fsJSYTxgyPmApMp4wbHzAUpZ5wtDxAcsBzjxh%2BPiA5SBHnjBlfMByoD1PmDY%2BYDnYtydMHR%2BwnICeMH18wHKS9ydcMj5gOVE84bLxAcuVYLkSLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLDvVQ5saLFeC5UqwXAmW69gev7WIMc4gs9idAAAAAElFTkSuQmCC)](https://www.nuget.org/packages/ConfigurationPlaceholders/)
[![License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square&logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAHYcAAB2HAY%2Fl8WUAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTCtCgrAAAADB0lEQVR4XtWagXETMRREUwIlUAIlUAodQAl0AJ1AB9BB6AA6gA6MduKbkX%2BevKecNk525jHO3l%2Fp686xlJC70%2Bl0C942vjV%2Bn9FreVQbBc0wWujfRpW8Z78JaIb53hhJ1ygTA80w9PQ36duBMjHQHPCuoQZfutSjeqU1PAJN4E3j2pN7aVKv6pnWcgGawNfGa5N6prVcgGZBn8yvVXZXQbOgPXokXaPMNZwoc41D%2FaHZ8b7hpBrKjnCizIjD%2FaHZ8aPR6%2BeZXqqh7Agnyow43B%2BaZz40qnQ36a6rlsYgnChDLOkPzTN1z%2B9PafU0N3OAcaIMsaQ%2FNBufG1X9JyrtDMr0Y4xwokxlWX%2BPjAYdemhPrWeDvYcPJ8r0LO3v4oszNfivQQuTp2u9qJGKE2V6lvZ38UVj9q3t3oqEE2U2lvfXF4t6qPjTqDUV1fRyhw8nymws768vfOr2NtqOqFY4UUZE%2BusL6VDRX7%2FGzOHDiTIi0t9WMPsUKzNPx4kysf62gmuHir3sPXw4USbWny485ZOc2PsJ7VTro%2F3pwp5DxV7qHq2xa41TrY%2F2J7PfJkaHir3UwwdtU061PtqfTP0CUaYm2v3LxCtoDI2lMWk8p1of7Y8K0jhRJgaaYZwoE0P%2FpFUndZqtP6T4BE2zC5qtP6T4BE2zC5qtPyRN8OvhZUQae3ZBtT7anyb49PA6Ivp5wKnWR%2FvbJkncZXr6wokysf62CXRCWjmJxhqd2JwoE%2BuvTqS37JGJlB39GLzhRJmN5f31gz8XTpSJgWYYJ8rEQDOME2VioBnGiTIx0AzjRJkYaIZxokwMNMM4USYGmmGcKBMDzTBOlImBZhgnysRAM4wTZWKgGcaJMjHQDONEmRhohnGiTAw0wzhRJgaaYZwoEwPNME6UiYFmGCfKxEAzjBNlYqAZxokyMdAMoL%2FO%2BNi4bzjpT1e%2BNFb8V7gFzUXMLHqk%2BM1A8wArFj1S5GagOUly0SMtuxloTnJrUU%2B7QXOSW4t62g2ak9xa1NNu0Jzk1qKednK6%2Bw9roIB8keT%2F3QAAAABJRU5ErkJggg%3D%3D)](LICENSE.md)
![Build](https://github.com/DaveSenn/ConfigurationPlaceholders/actions/workflows/github-actions.yml/badge.svg)

Adds support for placeholders in **any** configuration source (e.g. appsettings.json).

## Getting started

Install the [ConfigurationPlaceholders](https://www.nuget.org/packages/ConfigurationPlaceholders/) package from NuGet:

Package manager:
```powershell
Install-Package ConfigurationPlaceholders
```
Or via the .NET CLI
```pwsh
dotnet add package ConfigurationPlaceholders
```

You can add **ConfigurationPlaceholders** to your project with the `AddConfigurationPlaceholders` extension method.

```c#
 var builder = WebApplication.CreateBuilder( args ); 
 builder 
     .AddConfigurationPlaceholders( new InMemoryPlaceholderResolver( new Dictionary<String, String?> 
     { 
         { "FQDN", fullDomainName } 
     } ) ); 
```

This will replace the placeholder `${FQDN}` with the fully qualified name of the machine running the application.  
Placeholder in the `appsettings.json`:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "CertificateSubject": "${FQDN}"
}
```

You can specify any number of placeholder resolvers `IPlaceholderResolver` in the call to `AddConfigurationPlaceholders`.  
Later added placeholder resolvers `IPlaceholderResolver` will override values from before added placeholder resolvers `IPlaceholderResolver`.

### Placeholder verification
By default **ConfigurationPlaceholders** will check if values are provided for all placeholders. If there are any missing placeholder values a `ConfigurationPlaceholderMissingException` will be thrown.  
You can change this behavior by passing another `MissingPlaceholderValueStrategy` to `AddConfigurationPlaceholders`.

The following strategies are available:

#### VerifyAllAtStartup (**default**)
Will check if values are provided for all placeholders. If there are any missing placeholder values a `ConfigurationPlaceholderMissingException` will be thrown.

#### Throw
You can think of this one as a lazy execution version of `VerifyAllAtStartup`. Â 
A `ConfigurationPlaceholderMissingException` will be thrown when a configuration entry with a missing placeholder value is being accessed. If the value never gets accessed, no exception will be thrown.

#### UseEmptyValue
Placeholders for which no value is provided will be replaced with an empty string.  
`"Hello, ${MissingValue}"` will result in `"Hello, "`

#### IgnorePlaceholder
Placeholders for which no value is provided will not be replaced. The resulting value will still contain the placeholder.
`"Hello, ${MissingValue}"` will result in `"Hello, ${MissingValue}"`


### Examples
You can find some examples using **ConfigurationPlaceholders** [here](https://github.com/DaveSenn/ConfigurationPlaceholders/tree/doc/examples)


## Available placeholder resolvers `IPlaceholderResolver`

#### InMemoryPlaceholderResolver
Resolves placeholder values from an in-memory lookup. Works similar like the `AddInMemoryCollection` configuration source.

```c#
new InMemoryPlaceholderResolver( new Dictionary<String, String?>
{
    { "ApplicationName", Assembly.GetExecutingAssembly().GetName().Name },
    { "ApplicationVersion", Assembly.GetExecutingAssembly().GetName().Version!.ToString() }
} )
```

#### CallbackPlaceholderResolver
Resolves placeholder values by invoking user provided value factories.

```c#
new CallbackPlaceholderResolver( new Dictionary<String, Func<String?>>
{
    { "Time", () => DateTime.Now.ToString( "HH:mm:ss.fff" ) }
} )
```

#### ConfigurationPlaceholderResolver
Searches for values in all configuration sources matching the placeholder key.

```c#
new ConfigurationPlaceholderResolver()
```

In this example `LocalDb` is build based on other values in `appsettings.json`:
```json
{
  "Lookup": {
    "DataDir": "X:/Temp/",
    "DbDir": "${Lookup:DataDir}db/"
  },
  "LocalDb": "${Lookup:DbDir}store.db"
}
```

#### EnvironmentVariableResolver
Resolves placeholder values by searching for environment variables matching the placeholder key. The search is performed in this priority order:
1. EnvironmentVariableTarget.Process
2. EnvironmentVariableTarget.User
3. EnvironmentVariableTarget.Machine

```c#
new EnvironmentVariableResolver()
```

#### Custom providers
You can add your own placeholder resolvers by implementing `IPlaceholderResolver`.
Potential sources could be REST APIs, files, secret stores etc...


## How to add **ConfigurationPlaceholders** to your application
Different application setups require different ways to add **ConfigurationPlaceholders**.

#### WebApplication / minimal API

```c#
var builder = WebApplication.CreateBuilder( args );
builder
    .AddConfigurationPlaceholders( new InMemoryPlaceholderResolver( new Dictionary<String, String?>
    {
        { "FQDN", fullDomainName }
    } ) );
```

#### IHostBuilder / "old" ASP.NET / generic host

```c#
Host
    .CreateDefaultBuilder( args )
    .AddConfigurationPlaceholders( new InMemoryPlaceholderResolver( new Dictionary<String, String?>
    {
        { "FQDN", fullDomainName }
    } ) )
```

#### ConfigurationBuilder / console application

```c#
var configuration = new ConfigurationBuilder()
                    .AddJsonFile( "appsettings.json" )
                    ....
                    .AddConfigurationPlaceholders( new List<IPlaceholderResolver>
                    {
                        new InMemoryPlaceholderResolver( new Dictionary<String, String?>
                        {
                            {
                                "ApplicationName", Assembly.GetExecutingAssembly().GetName().Name
                            }
                        }
                        } ),
                        new EnvironmentVariableResolver()
                    } )
                    .Build();
```

## Recursive placeholders
You can reference values containing placeholders from placeholders...

```json
{
  "Lookup": {
    "SinksNs": "Serilog.Sinks",
    "DataDir": "X:/Temp/",
    "LogDir": "${Lookup:DataDir}logs/",
    "DbDir": "${Lookup:DataDir}db/"
  },
  "Serilog": {
    "Using": [ "${Lookup:SinksNs}.Console", "${Lookup:SinksNs}.File" ],
    "MinimumLevel": "Debug",
    "WriteTo": [
      { "Name": "Console" },
      {
        "Name": "File",
        "Args": { "path": "${Lookup:LogDir}${ApplicationName}/${ApplicationName}-${ApplicationVersion}.log" }
      }
    ]
  },
  "Test": "Today is the ${Today} (${Day}) an it is ${Time} ${NoValueDefinedForThisOne}",
  "LocalDb": "${Lookup:DbDir}store.db"
}
```

In this example we can see several placeholders referencing values containing other placeholders.  
E.g. `${Lookup:DbDir}` will be resolved with the value `${Lookup:DataDir}db/` from `Lookup:DbDir` (using `ConfigurationPlaceholderResolver`). `${Lookup:DataDir}` is another placeholder which will be replaced with the value of `Lookup:DataDir` => `X:/Temp/`.

**You can combine values from multiple `IPlaceholderResolver` with multiple configuration sources.** 